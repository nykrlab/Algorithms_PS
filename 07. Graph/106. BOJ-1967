# bfs 두번 이용해 O(n) 시간복잡도로 구현 가능

# 트리에서 아무 노드나 잡고(루트) 그 노드에 대해 가장 먼 노드 구하여 n1이라 지칭
# n1에서 가장 먼 노드 한 번 더 찾기 = n2
# n1과 n2의 거리가 트리의 지름이 됨


# 트리의 지름을 구하려면 가장 끝 노드끼리의 거리가 될 것이다. 그중에서도 가장 큰 가중치(거리)를 가지는 것이 최종 지름 
# 1. 루트 1번 시작으로 가장 먼 거리에 있는 즉, 가장 가중치 큰 끝 노드를 DFS로 찾는다
# 2. 찾은 끝 노드를 다시 루트노드로 설정해 BFS
# 3. 탐색하며 더한 가중치 값들 중 최댓값 출력 시 트리 지름 됨

import sys
input=sys.stdin.readline
sys.setrecursionlimit(10**9)

n=int(input())
graph=[[] for _ in range(n+1)]

def dfs(x,wei): # 가중치도
  for i in graph[x]:
    a,b=i
    if distance[a]==-1: #방문안했으면?
      distance[a]=wei+b
      dfs(a,wei+b)


for _ in range(n-1):
  a,b,c=map(int,input().split())
  graph[a].append([b,c])
  graph[b].append([a,c])

# root node에서 가장 먼 곳 찾기
distance=[-1]*(n+1)
distance[1]=0
dfs(1,0)

#위에서 찾은 노드에서 가장 먼 노드 찾기
start = distance.index(max(distance))
distance=[-1]*(n+1)
distance[start]=0
dfs(start,0)

print(max(distance))
