n,m = map(int,input().split()) #세로 가로 / 행렬

#BFS 아님
#여행을 하면서 방문한 칸의 수를 최대
#병든 나이트의 이동 횟수가 4번보다 적지 않다면(크거나 같다면), 이동 방법을 모두 한 번씩 사용해야 한다. 
#이동 횟수가 4번보다 적은 경우(방문한 칸이 5개 미만)에는 이동 방법에 대한 제약이 없다.

# n*m 크기 체스판의 가장 왼쪽아래에 위치

"""
2칸 위로, 1칸 오른쪽
1칸 위로, 2칸 오른쪽
1칸 아래로, 2칸 오른쪽
2칸 아래로, 1칸 오른쪽

무조건 오른쪽으로는 이동을 하게 되어있고, 위 아래로는 자유인 상황
"""


if n==1:
  print(1)
  # 행이 1인 경우에는 위아래로 움직일 수 없음 > 1 출력
  
elif n==2:
  print(min(4,(m+1)//2))
# 행이 2인 경우: 위로한칸오른쪽두칸 / 아래한칸오른쪽두칸의 경우만 이동 가능
# 따라서 열의 크기에 따라 몇 번 이동하는지 좌우됨
# 하지만 문제에서 이동횟수가 4보다 큰 경우, 주어진 이동방법 모두 이용해야한다고 했으므로 최대 4번 넘을 수 없기 때문에 min(4,(m+1)//2) 출력

else:
  if m<=6:
    print(min(4,m))
  # 오른쪽으로 이동하면서 이동횟수가 4를 넘지 않거나
  # 모든 방향 이동하는 경우의 수가 m이 6인 경우이므로 열이 6보다 작거나 같을 경우에는
  # min(4,m) 출력해줌 

  # 문제에서 제시한 4개의 움직임을 모두 사용해야 한다는 규칙을 기억하자.
#2칸 위로, 1칸 오른쪽 => X : 1칸 필요
#1칸 위로, 2칸 오른쪽 => X : 2칸 필요
#1칸 아래로, 2칸 오른쪽 => X : 2칸 필요
#2칸 아래로, 1칸 오른쪽 => X : 1칸 필요
    # X는 1부터 시작하는데 4개 움직임을 다 사용하면 1 + ( 1 + 2 + 2 + 1 ) = 7이 되므로 조건을 충족시켜줄 수 없다. 그러므로 4와 X 값 중에서 더 작은 값을 출력해주어야 한다.


  else:
    print(m-2)

  # 방문한 칸의 수를 최대로 하면서 이동방법을 모두 한 번씩 사용하려면 오른쪽으로 2칸 가야하는 경우를 1번씩만 사용해주고 나머지는 모두 1칸 오른쪽으로 가는 방법을 선택해주어야한다

  # 그 외에는 4가지 방법 모두 사용해야하므로 - 오른쪽으로 두번 이동해야하는 방법 2번일 때 생략되는 2번만 입력받은 열에서 빼준 값을 출력하면 된다
